package org.apache.batik.ext.awt.image.codec.tiff;
class TIFFFaxDecoder {
    private int bitPointer;
    private int bytePointer;
    private byte[] data;
    private int w;
    private int h;
    private int fillOrder;
    private int changingElemSize = 0;
    private int[] prevChangingElems;
    private int[] currChangingElems;
    private int lastChangingElement = 0;
    private int compression = 2;
    private int uncompressedMode = 0;
    private int fillBits = 0;
    private int oneD;
    static int[] table1 = { 0, 1, 3, 7, 15, 31, 63, 127, 255 };
    static int[] table2 = { 0, 128, 192, 224, 240, 248, 252, 254, 255 };
    static byte[] flipTable = { 0, -128, 64, -64, 32, -96, 96, -32, 16, -112,
    80,
    -48,
    48,
    -80,
    112,
    -16,
    8,
    -120,
    72,
    -56,
    40,
    -88,
    104,
    -24,
    24,
    -104,
    88,
    -40,
    56,
    -72,
    120,
    -8,
    4,
    -124,
    68,
    -60,
    36,
    -92,
    100,
    -28,
    20,
    -108,
    84,
    -44,
    52,
    -76,
    116,
    -12,
    12,
    -116,
    76,
    -52,
    44,
    -84,
    108,
    -20,
    28,
    -100,
    92,
    -36,
    60,
    -68,
    124,
    -4,
    2,
    -126,
    66,
    -62,
    34,
    -94,
    98,
    -30,
    18,
    -110,
    82,
    -46,
    50,
    -78,
    114,
    -14,
    10,
    -118,
    74,
    -54,
    42,
    -86,
    106,
    -22,
    26,
    -102,
    90,
    -38,
    58,
    -70,
    122,
    -6,
    6,
    -122,
    70,
    -58,
    38,
    -90,
    102,
    -26,
    22,
    -106,
    86,
    -42,
    54,
    -74,
    118,
    -10,
    14,
    -114,
    78,
    -50,
    46,
    -82,
    110,
    -18,
    30,
    -98,
    94,
    -34,
    62,
    -66,
    126,
    -2,
    1,
    -127,
    65,
    -63,
    33,
    -95,
    97,
    -31,
    17,
    -111,
    81,
    -47,
    49,
    -79,
    113,
    -15,
    9,
    -119,
    73,
    -55,
    41,
    -87,
    105,
    -23,
    25,
    -103,
    89,
    -39,
    57,
    -71,
    121,
    -7,
    5,
    -123,
    69,
    -59,
    37,
    -91,
    101,
    -27,
    21,
    -107,
    85,
    -43,
    53,
    -75,
    117,
    -11,
    13,
    -115,
    77,
    -51,
    45,
    -83,
    109,
    -19,
    29,
    -99,
    93,
    -35,
    61,
    -67,
    125,
    -3,
    3,
    -125,
    67,
    -61,
    35,
    -93,
    99,
    -29,
    19,
    -109,
    83,
    -45,
    51,
    -77,
    115,
    -13,
    11,
    -117,
    75,
    -53,
    43,
    -85,
    107,
    -21,
    27,
    -101,
    91,
    -37,
    59,
    -69,
    123,
    -5,
    7,
    -121,
    71,
    -57,
    39,
    -89,
    103,
    -25,
    23,
    -105,
    87,
    -41,
    55,
    -73,
    119,
    -9,
    15,
    -113,
    79,
    -49,
    47,
    -81,
    111,
    -17,
    31,
    -97,
    95,
    -33,
    63,
    -65,
    127,
    -1 };
    static short[] white = { 6430, 6400, 6400, 6400, 3225, 3225, 3225, 3225,
    944,
    944,
    944,
    944,
    976,
    976,
    976,
    976,
    1456,
    1456,
    1456,
    1456,
    1488,
    1488,
    1488,
    1488,
    718,
    718,
    718,
    718,
    718,
    718,
    718,
    718,
    750,
    750,
    750,
    750,
    750,
    750,
    750,
    750,
    1520,
    1520,
    1520,
    1520,
    1552,
    1552,
    1552,
    1552,
    428,
    428,
    428,
    428,
    428,
    428,
    428,
    428,
    428,
    428,
    428,
    428,
    428,
    428,
    428,
    428,
    654,
    654,
    654,
    654,
    654,
    654,
    654,
    654,
    1072,
    1072,
    1072,
    1072,
    1104,
    1104,
    1104,
    1104,
    1136,
    1136,
    1136,
    1136,
    1168,
    1168,
    1168,
    1168,
    1200,
    1200,
    1200,
    1200,
    1232,
    1232,
    1232,
    1232,
    622,
    622,
    622,
    622,
    622,
    622,
    622,
    622,
    1008,
    1008,
    1008,
    1008,
    1040,
    1040,
    1040,
    1040,
    44,
    44,
    44,
    44,
    44,
    44,
    44,
    44,
    44,
    44,
    44,
    44,
    44,
    44,
    44,
    44,
    396,
    396,
    396,
    396,
    396,
    396,
    396,
    396,
    396,
    396,
    396,
    396,
    396,
    396,
    396,
    396,
    1712,
    1712,
    1712,
    1712,
    1744,
    1744,
    1744,
    1744,
    846,
    846,
    846,
    846,
    846,
    846,
    846,
    846,
    1264,
    1264,
    1264,
    1264,
    1296,
    1296,
    1296,
    1296,
    1328,
    1328,
    1328,
    1328,
    1360,
    1360,
    1360,
    1360,
    1392,
    1392,
    1392,
    1392,
    1424,
    1424,
    1424,
    1424,
    686,
    686,
    686,
    686,
    686,
    686,
    686,
    686,
    910,
    910,
    910,
    910,
    910,
    910,
    910,
    910,
    1968,
    1968,
    1968,
    1968,
    2000,
    2000,
    2000,
    2000,
    2032,
    2032,
    2032,
    2032,
    16,
    16,
    16,
    16,
    10257,
    10257,
    10257,
    10257,
    12305,
    12305,
    12305,
    12305,
    330,
    330,
    330,
    330,
    330,
    330,
    330,
    330,
    330,
    330,
    330,
    330,
    330,
    330,
    330,
    330,
    330,
    330,
    330,
    330,
    330,
    330,
    330,
    330,
    330,
    330,
    330,
    330,
    330,
    330,
    330,
    330,
    362,
    362,
    362,
    362,
    362,
    362,
    362,
    362,
    362,
    362,
    362,
    362,
    362,
    362,
    362,
    362,
    362,
    362,
    362,
    362,
    362,
    362,
    362,
    362,
    362,
    362,
    362,
    362,
    362,
    362,
    362,
    362,
    878,
    878,
    878,
    878,
    878,
    878,
    878,
    878,
    1904,
    1904,
    1904,
    1904,
    1936,
    1936,
    1936,
    1936,
    -18413,
    -18413,
    -16365,
    -16365,
    -14317,
    -14317,
    -10221,
    -10221,
    590,
    590,
    590,
    590,
    590,
    590,
    590,
    590,
    782,
    782,
    782,
    782,
    782,
    782,
    782,
    782,
    1584,
    1584,
    1584,
    1584,
    1616,
    1616,
    1616,
    1616,
    1648,
    1648,
    1648,
    1648,
    1680,
    1680,
    1680,
    1680,
    814,
    814,
    814,
    814,
    814,
    814,
    814,
    814,
    1776,
    1776,
    1776,
    1776,
    1808,
    1808,
    1808,
    1808,
    1840,
    1840,
    1840,
    1840,
    1872,
    1872,
    1872,
    1872,
    6157,
    6157,
    6157,
    6157,
    6157,
    6157,
    6157,
    6157,
    6157,
    6157,
    6157,
    6157,
    6157,
    6157,
    6157,
    6157,
    -12275,
    -12275,
    -12275,
    -12275,
    -12275,
    -12275,
    -12275,
    -12275,
    -12275,
    -12275,
    -12275,
    -12275,
    -12275,
    -12275,
    -12275,
    -12275,
    14353,
    14353,
    14353,
    14353,
    16401,
    16401,
    16401,
    16401,
    22547,
    22547,
    24595,
    24595,
    20497,
    20497,
    20497,
    20497,
    18449,
    18449,
    18449,
    18449,
    26643,
    26643,
    28691,
    28691,
    30739,
    30739,
    -32749,
    -32749,
    -30701,
    -30701,
    -28653,
    -28653,
    -26605,
    -26605,
    -24557,
    -24557,
    -22509,
    -22509,
    -20461,
    -20461,
    8207,
    8207,
    8207,
    8207,
    8207,
    8207,
    8207,
    8207,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    4107,
    4107,
    4107,
    4107,
    4107,
    4107,
    4107,
    4107,
    4107,
    4107,
    4107,
    4107,
    4107,
    4107,
    4107,
    4107,
    4107,
    4107,
    4107,
    4107,
    4107,
    4107,
    4107,
    4107,
    4107,
    4107,
    4107,
    4107,
    4107,
    4107,
    4107,
    4107,
    266,
    266,
    266,
    266,
    266,
    266,
    266,
    266,
    266,
    266,
    266,
    266,
    266,
    266,
    266,
    266,
    266,
    266,
    266,
    266,
    266,
    266,
    266,
    266,
    266,
    266,
    266,
    266,
    266,
    266,
    266,
    266,
    298,
    298,
    298,
    298,
    298,
    298,
    298,
    298,
    298,
    298,
    298,
    298,
    298,
    298,
    298,
    298,
    298,
    298,
    298,
    298,
    298,
    298,
    298,
    298,
    298,
    298,
    298,
    298,
    298,
    298,
    298,
    298,
    524,
    524,
    524,
    524,
    524,
    524,
    524,
    524,
    524,
    524,
    524,
    524,
    524,
    524,
    524,
    524,
    556,
    556,
    556,
    556,
    556,
    556,
    556,
    556,
    556,
    556,
    556,
    556,
    556,
    556,
    556,
    556,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    460,
    460,
    460,
    460,
    460,
    460,
    460,
    460,
    460,
    460,
    460,
    460,
    460,
    460,
    460,
    460,
    492,
    492,
    492,
    492,
    492,
    492,
    492,
    492,
    492,
    492,
    492,
    492,
    492,
    492,
    492,
    492,
    2059,
    2059,
    2059,
    2059,
    2059,
    2059,
    2059,
    2059,
    2059,
    2059,
    2059,
    2059,
    2059,
    2059,
    2059,
    2059,
    2059,
    2059,
    2059,
    2059,
    2059,
    2059,
    2059,
    2059,
    2059,
    2059,
    2059,
    2059,
    2059,
    2059,
    2059,
    2059,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232 };
    static short[] additionalMakeup = { 28679, 28679, 31752, (short) 32777,
    (short)
      33801,
    (short)
      34825,
    (short)
      35849,
    (short)
      36873,
    (short)
      29703,
    (short)
      29703,
    (short)
      30727,
    (short)
      30727,
    (short)
      37897,
    (short)
      38921,
    (short)
      39945,
    (short)
      40969 };
    static short[] initBlack = { 3226, 6412, 200, 168, 38, 38, 134, 134, 100,
    100,
    100,
    100,
    68,
    68,
    68,
    68 };
    static short[] twoBitBlack = { 292, 260, 226, 226 };
    static short[] black = { 62, 62, 30, 30, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    3225,
    3225,
    3225,
    3225,
    3225,
    3225,
    3225,
    3225,
    3225,
    3225,
    3225,
    3225,
    3225,
    3225,
    3225,
    3225,
    3225,
    3225,
    3225,
    3225,
    3225,
    3225,
    3225,
    3225,
    3225,
    3225,
    3225,
    3225,
    3225,
    3225,
    3225,
    3225,
    588,
    588,
    588,
    588,
    588,
    588,
    588,
    588,
    1680,
    1680,
    20499,
    22547,
    24595,
    26643,
    1776,
    1776,
    1808,
    1808,
    -24557,
    -22509,
    -20461,
    -18413,
    1904,
    1904,
    1936,
    1936,
    -16365,
    -14317,
    782,
    782,
    782,
    782,
    814,
    814,
    814,
    814,
    -12269,
    -10221,
    10257,
    10257,
    12305,
    12305,
    14353,
    14353,
    16403,
    18451,
    1712,
    1712,
    1744,
    1744,
    28691,
    30739,
    -32749,
    -30701,
    -28653,
    -26605,
    2061,
    2061,
    2061,
    2061,
    2061,
    2061,
    2061,
    2061,
    424,
    424,
    424,
    424,
    424,
    424,
    424,
    424,
    424,
    424,
    424,
    424,
    424,
    424,
    424,
    424,
    424,
    424,
    424,
    424,
    424,
    424,
    424,
    424,
    424,
    424,
    424,
    424,
    424,
    424,
    424,
    424,
    750,
    750,
    750,
    750,
    1616,
    1616,
    1648,
    1648,
    1424,
    1424,
    1456,
    1456,
    1488,
    1488,
    1520,
    1520,
    1840,
    1840,
    1872,
    1872,
    1968,
    1968,
    8209,
    8209,
    524,
    524,
    524,
    524,
    524,
    524,
    524,
    524,
    556,
    556,
    556,
    556,
    556,
    556,
    556,
    556,
    1552,
    1552,
    1584,
    1584,
    2000,
    2000,
    2032,
    2032,
    976,
    976,
    1008,
    1008,
    1040,
    1040,
    1072,
    1072,
    1296,
    1296,
    1328,
    1328,
    718,
    718,
    718,
    718,
    456,
    456,
    456,
    456,
    456,
    456,
    456,
    456,
    456,
    456,
    456,
    456,
    456,
    456,
    456,
    456,
    456,
    456,
    456,
    456,
    456,
    456,
    456,
    456,
    456,
    456,
    456,
    456,
    456,
    456,
    456,
    456,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    490,
    490,
    490,
    490,
    490,
    490,
    490,
    490,
    490,
    490,
    490,
    490,
    490,
    490,
    490,
    490,
    4113,
    4113,
    6161,
    6161,
    848,
    848,
    880,
    880,
    912,
    912,
    944,
    944,
    622,
    622,
    622,
    622,
    654,
    654,
    654,
    654,
    1104,
    1104,
    1136,
    1136,
    1168,
    1168,
    1200,
    1200,
    1232,
    1232,
    1264,
    1264,
    686,
    686,
    686,
    686,
    1360,
    1360,
    1392,
    1392,
    12,
    12,
    12,
    12,
    12,
    12,
    12,
    12,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390 };
    static byte[] twoDCodes = { 80, 88, 23, 71, 30, 30, 62, 62, 4, 4, 4, 4,
    4,
    4,
    4,
    4,
    11,
    11,
    11,
    11,
    11,
    11,
    11,
    11,
    11,
    11,
    11,
    11,
    11,
    11,
    11,
    11,
    35,
    35,
    35,
    35,
    35,
    35,
    35,
    35,
    35,
    35,
    35,
    35,
    35,
    35,
    35,
    35,
    51,
    51,
    51,
    51,
    51,
    51,
    51,
    51,
    51,
    51,
    51,
    51,
    51,
    51,
    51,
    51,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41 };
    public TIFFFaxDecoder(int fillOrder, int w, int h) { super();
                                                         this.fillOrder =
                                                           fillOrder;
                                                         this.w = w;
                                                         this.h = h;
                                                         this.bitPointer =
                                                           0;
                                                         this.bytePointer =
                                                           0;
                                                         this.prevChangingElems =
                                                           (new int[w]);
                                                         this.currChangingElems =
                                                           (new int[w]);
    }
    public void decode1D(byte[] buffer, byte[] compData, int startX,
                         int height) { this.data = compData;
                                       int lineOffset = 0;
                                       int scanlineStride =
                                         (w +
                                            7) /
                                         8;
                                       bitPointer = 0;
                                       bytePointer = 0;
                                       for (int i = 0; i <
                                                         height;
                                            i++) { decodeNextScanline(
                                                     buffer,
                                                     lineOffset,
                                                     startX);
                                                   lineOffset +=
                                                     scanlineStride;
                                       } }
    public void decodeNextScanline(byte[] buffer, int lineOffset,
                                   int bitOffset) { int bits =
                                                      0;
                                                    int code =
                                                      0;
                                                    int isT =
                                                      0;
                                                    int current;
                                                    int entry;
                                                    int twoBits;
                                                    boolean isWhite =
                                                      true;
                                                    changingElemSize =
                                                      0;
                                                    while (bitOffset <
                                                             w) {
                                                        while (isWhite) {
                                                            current =
                                                              nextNBits(
                                                                10);
                                                            entry =
                                                              white[current];
                                                            isT =
                                                              entry &
                                                                1;
                                                            bits =
                                                              entry >>>
                                                                1 &
                                                                15;
                                                            if (bits ==
                                                                  12) {
                                                                twoBits =
                                                                  nextLesserThan8Bits(
                                                                    2);
                                                                current =
                                                                  current <<
                                                                    2 &
                                                                    12 |
                                                                    twoBits;
                                                                entry =
                                                                  additionalMakeup[current];
                                                                bits =
                                                                  entry >>>
                                                                    1 &
                                                                    7;
                                                                code =
                                                                  entry >>>
                                                                    4 &
                                                                    4095;
                                                                bitOffset +=
                                                                  code;
                                                                updatePointer(
                                                                  4 -
                                                                    bits);
                                                            }
                                                            else
                                                                if (bits ==
                                                                      0) {
                                                                    throw new java.lang.Error(
                                                                      "TIFFFaxDecoder0");
                                                                }
                                                                else
                                                                    if (bits ==
                                                                          15) {
                                                                        throw new java.lang.Error(
                                                                          "TIFFFaxDecoder1");
                                                                    }
                                                                    else {
                                                                        code =
                                                                          entry >>>
                                                                            5 &
                                                                            2047;
                                                                        bitOffset +=
                                                                          code;
                                                                        updatePointer(
                                                                          10 -
                                                                            bits);
                                                                        if (isT ==
                                                                              0) {
                                                                            isWhite =
                                                                              false;
                                                                            currChangingElems[changingElemSize++] =
                                                                              bitOffset;
                                                                        }
                                                                    }
                                                        }
                                                        if (bitOffset ==
                                                              w) {
                                                            if (compression ==
                                                                  2) {
                                                                advancePointer(
                                                                  );
                                                            }
                                                            break;
                                                        }
                                                        while (!isWhite) {
                                                            current =
                                                              nextLesserThan8Bits(
                                                                4);
                                                            entry =
                                                              initBlack[current];
                                                            isT =
                                                              entry &
                                                                1;
                                                            bits =
                                                              entry >>>
                                                                1 &
                                                                15;
                                                            code =
                                                              entry >>>
                                                                5 &
                                                                2047;
                                                            if (code ==
                                                                  100) {
                                                                current =
                                                                  nextNBits(
                                                                    9);
                                                                entry =
                                                                  black[current];
                                                                isT =
                                                                  entry &
                                                                    1;
                                                                bits =
                                                                  entry >>>
                                                                    1 &
                                                                    15;
                                                                code =
                                                                  entry >>>
                                                                    5 &
                                                                    2047;
                                                                if (bits ==
                                                                      12) {
                                                                    updatePointer(
                                                                      5);
                                                                    current =
                                                                      nextLesserThan8Bits(
                                                                        4);
                                                                    entry =
                                                                      additionalMakeup[current];
                                                                    bits =
                                                                      entry >>>
                                                                        1 &
                                                                        7;
                                                                    code =
                                                                      entry >>>
                                                                        4 &
                                                                        4095;
                                                                    setToBlack(
                                                                      buffer,
                                                                      lineOffset,
                                                                      bitOffset,
                                                                      code);
                                                                    bitOffset +=
                                                                      code;
                                                                    updatePointer(
                                                                      4 -
                                                                        bits);
                                                                }
                                                                else
                                                                    if (bits ==
                                                                          15) {
                                                                        throw new java.lang.Error(
                                                                          "TIFFFaxDecoder2");
                                                                    }
                                                                    else {
                                                                        setToBlack(
                                                                          buffer,
                                                                          lineOffset,
                                                                          bitOffset,
                                                                          code);
                                                                        bitOffset +=
                                                                          code;
                                                                        updatePointer(
                                                                          9 -
                                                                            bits);
                                                                        if (isT ==
                                                                              0) {
                                                                            isWhite =
                                                                              true;
                                                                            currChangingElems[changingElemSize++] =
                                                                              bitOffset;
                                                                        }
                                                                    }
                                                            }
                                                            else
                                                                if (code ==
                                                                      200) {
                                                                    current =
                                                                      nextLesserThan8Bits(
                                                                        2);
                                                                    entry =
                                                                      twoBitBlack[current];
                                                                    code =
                                                                      entry >>>
                                                                        5 &
                                                                        2047;
                                                                    bits =
                                                                      entry >>>
                                                                        1 &
                                                                        15;
                                                                    setToBlack(
                                                                      buffer,
                                                                      lineOffset,
                                                                      bitOffset,
                                                                      code);
                                                                    bitOffset +=
                                                                      code;
                                                                    updatePointer(
                                                                      2 -
                                                                        bits);
                                                                    isWhite =
                                                                      true;
                                                                    currChangingElems[changingElemSize++] =
                                                                      bitOffset;
                                                                }
                                                                else {
                                                                    setToBlack(
                                                                      buffer,
                                                                      lineOffset,
                                                                      bitOffset,
                                                                      code);
                                                                    bitOffset +=
                                                                      code;
                                                                    updatePointer(
                                                                      4 -
                                                                        bits);
                                                                    isWhite =
                                                                      true;
                                                                    currChangingElems[changingElemSize++] =
                                                                      bitOffset;
                                                                }
                                                        }
                                                        if (bitOffset ==
                                                              w) {
                                                            if (compression ==
                                                                  2) {
                                                                advancePointer(
                                                                  );
                                                            }
                                                            break;
                                                        }
                                                    }
                                                    currChangingElems[changingElemSize++] =
                                                      bitOffset;
    }
    public void decode2D(byte[] buffer, byte[] compData,
                         int startX,
                         int height,
                         long tiffT4Options) {
        this.
          data =
          compData;
        compression =
          3;
        bitPointer =
          0;
        bytePointer =
          0;
        int scanlineStride =
          (w +
             7) /
          8;
        int a0;
        int a1;
        int b1;
        int b2;
        int[] b =
          new int[2];
        int entry;
        int code;
        int bits;
        boolean isWhite;
        int currIndex =
          0;
        int[] temp;
        oneD =
          (int)
            (tiffT4Options &
               1);
        uncompressedMode =
          (int)
            ((tiffT4Options &
                2) >>
               1);
        fillBits =
          (int)
            ((tiffT4Options &
                4) >>
               2);
        if (readEOL(
              ) !=
              1) {
            throw new java.lang.Error(
              "TIFFFaxDecoder3");
        }
        int lineOffset =
          0;
        int bitOffset;
        decodeNextScanline(
          buffer,
          lineOffset,
          startX);
        lineOffset +=
          scanlineStride;
        for (int lines =
               1;
             lines <
               height;
             lines++) {
            if (readEOL(
                  ) ==
                  0) {
                temp =
                  prevChangingElems;
                prevChangingElems =
                  currChangingElems;
                currChangingElems =
                  temp;
                currIndex =
                  0;
                a0 =
                  -1;
                isWhite =
                  true;
                bitOffset =
                  startX;
                lastChangingElement =
                  0;
                while (bitOffset <
                         w) {
                    getNextChangingElement(
                      a0,
                      isWhite,
                      b);
                    b1 =
                      b[0];
                    b2 =
                      b[1];
                    entry =
                      nextLesserThan8Bits(
                        7);
                    entry =
                      (int)
                        (twoDCodes[entry] &
                           255);
                    code =
                      (entry &
                         120) >>>
                        3;
                    bits =
                      entry &
                        7;
                    if (code ==
                          0) {
                        if (!isWhite) {
                            setToBlack(
                              buffer,
                              lineOffset,
                              bitOffset,
                              b2 -
                                bitOffset);
                        }
                        bitOffset =
                          (a0 =
                             b2);
                        updatePointer(
                          7 -
                            bits);
                    }
                    else
                        if (code ==
                              1) {
                            updatePointer(
                              7 -
                                bits);
                            int number;
                            if (isWhite) {
                                number =
                                  decodeWhiteCodeWord(
                                    );
                                bitOffset +=
                                  number;
                                currChangingElems[currIndex++] =
                                  bitOffset;
                                number =
                                  decodeBlackCodeWord(
                                    );
                                setToBlack(
                                  buffer,
                                  lineOffset,
                                  bitOffset,
                                  number);
                                bitOffset +=
                                  number;
                                currChangingElems[currIndex++] =
                                  bitOffset;
                            }
                            else {
                                number =
                                  decodeBlackCodeWord(
                                    );
                                setToBlack(
                                  buffer,
                                  lineOffset,
                                  bitOffset,
                                  number);
                                bitOffset +=
                                  number;
                                currChangingElems[currIndex++] =
                                  bitOffset;
                                number =
                                  decodeWhiteCodeWord(
                                    );
                                bitOffset +=
                                  number;
                                currChangingElems[currIndex++] =
                                  bitOffset;
                            }
                            a0 =
                              bitOffset;
                        }
                        else
                            if (code <=
                                  8) {
                                a1 =
                                  b1 +
                                    (code -
                                       5);
                                currChangingElems[currIndex++] =
                                  a1;
                                if (!isWhite) {
                                    setToBlack(
                                      buffer,
                                      lineOffset,
                                      bitOffset,
                                      a1 -
                                        bitOffset);
                                }
                                bitOffset =
                                  (a0 =
                                     a1);
                                isWhite =
                                  !isWhite;
                                updatePointer(
                                  7 -
                                    bits);
                            }
                            else {
                                throw new java.lang.Error(
                                  "TIFFFaxDecoder4");
                            }
                }
                currChangingElems[currIndex++] =
                  bitOffset;
                changingElemSize =
                  currIndex;
            }
            else {
                decodeNextScanline(
                  buffer,
                  lineOffset,
                  startX);
            }
            lineOffset +=
              scanlineStride;
        }
    }
    public synchronized void decodeT6(byte[] buffer,
                                      byte[] compData,
                                      int startX,
                                      int height,
                                      long tiffT6Options) {
        this.
          data =
          compData;
        compression =
          4;
        bitPointer =
          0;
        bytePointer =
          0;
        int scanlineStride =
          (w +
             7) /
          8;
        int a0;
        int a1;
        int b1;
        int b2;
        int entry;
        int code;
        int bits;
        boolean isWhite;
        int currIndex;
        int[] temp;
        int[] b =
          new int[2];
        uncompressedMode =
          (int)
            ((tiffT6Options &
                2) >>
               1);
        int[] cce =
          currChangingElems;
        changingElemSize =
          0;
        cce[changingElemSize++] =
          w;
        cce[changingElemSize++] =
          w;
        int lineOffset =
          0;
        int bitOffset;
        for (int lines =
               0;
             lines <
               height;
             lines++) {
            a0 =
              -1;
            isWhite =
              true;
            temp =
              prevChangingElems;
            prevChangingElems =
              currChangingElems;
            cce =
              (currChangingElems =
                 temp);
            currIndex =
              0;
            bitOffset =
              startX;
            lastChangingElement =
              0;
            while (bitOffset <
                     w) {
                getNextChangingElement(
                  a0,
                  isWhite,
                  b);
                b1 =
                  b[0];
                b2 =
                  b[1];
                entry =
                  nextLesserThan8Bits(
                    7);
                entry =
                  (int)
                    (twoDCodes[entry] &
                       255);
                code =
                  (entry &
                     120) >>>
                    3;
                bits =
                  entry &
                    7;
                if (code ==
                      0) {
                    if (!isWhite) {
                        setToBlack(
                          buffer,
                          lineOffset,
                          bitOffset,
                          b2 -
                            bitOffset);
                    }
                    bitOffset =
                      (a0 =
                         b2);
                    updatePointer(
                      7 -
                        bits);
                }
                else
                    if (code ==
                          1) {
                        updatePointer(
                          7 -
                            bits);
                        int number;
                        if (isWhite) {
                            number =
                              decodeWhiteCodeWord(
                                );
                            bitOffset +=
                              number;
                            cce[currIndex++] =
                              bitOffset;
                            number =
                              decodeBlackCodeWord(
                                );
                            setToBlack(
                              buffer,
                              lineOffset,
                              bitOffset,
                              number);
                            bitOffset +=
                              number;
                            cce[currIndex++] =
                              bitOffset;
                        }
                        else {
                            number =
                              decodeBlackCodeWord(
                                );
                            setToBlack(
                              buffer,
                              lineOffset,
                              bitOffset,
                              number);
                            bitOffset +=
                              number;
                            cce[currIndex++] =
                              bitOffset;
                            number =
                              decodeWhiteCodeWord(
                                );
                            bitOffset +=
                              number;
                            cce[currIndex++] =
                              bitOffset;
                        }
                        a0 =
                          bitOffset;
                    }
                    else
                        if (code <=
                              8) {
                            a1 =
                              b1 +
                                (code -
                                   5);
                            cce[currIndex++] =
                              a1;
                            if (!isWhite) {
                                setToBlack(
                                  buffer,
                                  lineOffset,
                                  bitOffset,
                                  a1 -
                                    bitOffset);
                            }
                            bitOffset =
                              (a0 =
                                 a1);
                            isWhite =
                              !isWhite;
                            updatePointer(
                              7 -
                                bits);
                        }
                        else
                            if (code ==
                                  11) {
                                if (nextLesserThan8Bits(
                                      3) !=
                                      7) {
                                    throw new java.lang.Error(
                                      "TIFFFaxDecoder5");
                                }
                                int zeros =
                                  0;
                                boolean exit =
                                  false;
                                while (!exit) {
                                    while (nextLesserThan8Bits(
                                             1) !=
                                             1) {
                                        zeros++;
                                    }
                                    if (zeros >
                                          5) {
                                        zeros =
                                          zeros -
                                            6;
                                        if (!isWhite &&
                                              zeros >
                                              0) {
                                            cce[currIndex++] =
                                              bitOffset;
                                        }
                                        bitOffset +=
                                          zeros;
                                        if (zeros >
                                              0) {
                                            isWhite =
                                              true;
                                        }
                                        if (nextLesserThan8Bits(
                                              1) ==
                                              0) {
                                            if (!isWhite) {
                                                cce[currIndex++] =
                                                  bitOffset;
                                            }
                                            isWhite =
                                              true;
                                        }
                                        else {
                                            if (isWhite) {
                                                cce[currIndex++] =
                                                  bitOffset;
                                            }
                                            isWhite =
                                              false;
                                        }
                                        exit =
                                          true;
                                    }
                                    if (zeros ==
                                          5) {
                                        if (!isWhite) {
                                            cce[currIndex++] =
                                              bitOffset;
                                        }
                                        bitOffset +=
                                          zeros;
                                        isWhite =
                                          true;
                                    }
                                    else {
                                        bitOffset +=
                                          zeros;
                                        cce[currIndex++] =
                                          bitOffset;
                                        setToBlack(
                                          buffer,
                                          lineOffset,
                                          bitOffset,
                                          1);
                                        ++bitOffset;
                                        isWhite =
                                          false;
                                    }
                                }
                            }
                            else {
                                throw new java.lang.Error(
                                  "TIFFFaxDecoder5");
                            }
            }
            cce[currIndex++] =
              bitOffset;
            changingElemSize =
              currIndex;
            lineOffset +=
              scanlineStride;
        }
    }
    private void setToBlack(byte[] buffer,
                            int lineOffset,
                            int bitOffset,
                            int numBits) {
        int bitNum =
          8 *
          lineOffset +
          bitOffset;
        int lastBit =
          bitNum +
          numBits;
        int byteNum =
          bitNum >>
          3;
        int shift =
          bitNum &
          7;
        if (shift >
              0) {
            int maskVal =
              1 <<
              7 -
              shift;
            byte val =
              buffer[byteNum];
            while (maskVal >
                     0 &&
                     bitNum <
                     lastBit) {
                val |=
                  maskVal;
                maskVal >>=
                  1;
                ++bitNum;
            }
            buffer[byteNum] =
              val;
        }
        byteNum =
          bitNum >>
            3;
        while (bitNum <
                 lastBit -
                 7) {
            buffer[byteNum++] =
              (byte)
                255;
            bitNum +=
              8;
        }
        while (bitNum <
                 lastBit) {
            byteNum =
              bitNum >>
                3;
            buffer[byteNum] |=
              1 <<
                7 -
                (bitNum &
                   7);
            ++bitNum;
        }
    }
    private int decodeWhiteCodeWord() { int current;
                                        int entry;
                                        int bits;
                                        int isT;
                                        int twoBits;
                                        int code =
                                          -1;
                                        int runLength =
                                          0;
                                        boolean isWhite =
                                          true;
                                        while (isWhite) {
                                            current =
                                              nextNBits(
                                                10);
                                            entry =
                                              white[current];
                                            isT =
                                              entry &
                                                1;
                                            bits =
                                              entry >>>
                                                1 &
                                                15;
                                            if (bits ==
                                                  12) {
                                                twoBits =
                                                  nextLesserThan8Bits(
                                                    2);
                                                current =
                                                  current <<
                                                    2 &
                                                    12 |
                                                    twoBits;
                                                entry =
                                                  additionalMakeup[current];
                                                bits =
                                                  entry >>>
                                                    1 &
                                                    7;
                                                code =
                                                  entry >>>
                                                    4 &
                                                    4095;
                                                runLength +=
                                                  code;
                                                updatePointer(
                                                  4 -
                                                    bits);
                                            }
                                            else
                                                if (bits ==
                                                      0) {
                                                    throw new java.lang.Error(
                                                      "TIFFFaxDecoder0");
                                                }
                                                else
                                                    if (bits ==
                                                          15) {
                                                        throw new java.lang.Error(
                                                          "TIFFFaxDecoder1");
                                                    }
                                                    else {
                                                        code =
                                                          entry >>>
                                                            5 &
                                                            2047;
                                                        runLength +=
                                                          code;
                                                        updatePointer(
                                                          10 -
                                                            bits);
                                                        if (isT ==
                                                              0) {
                                                            isWhite =
                                                              false;
                                                        }
                                                    }
                                        }
                                        return runLength;
    }
    private int decodeBlackCodeWord() { int current;
                                        int entry;
                                        int bits;
                                        int isT;
                                        int code =
                                          -1;
                                        int runLength =
                                          0;
                                        boolean isWhite =
                                          false;
                                        while (!isWhite) {
                                            current =
                                              nextLesserThan8Bits(
                                                4);
                                            entry =
                                              initBlack[current];
                                            isT =
                                              entry &
                                                1;
                                            bits =
                                              entry >>>
                                                1 &
                                                15;
                                            code =
                                              entry >>>
                                                5 &
                                                2047;
                                            if (code ==
                                                  100) {
                                                current =
                                                  nextNBits(
                                                    9);
                                                entry =
                                                  black[current];
                                                isT =
                                                  entry &
                                                    1;
                                                bits =
                                                  entry >>>
                                                    1 &
                                                    15;
                                                code =
                                                  entry >>>
                                                    5 &
                                                    2047;
                                                if (bits ==
                                                      12) {
                                                    updatePointer(
                                                      5);
                                                    current =
                                                      nextLesserThan8Bits(
                                                        4);
                                                    entry =
                                                      additionalMakeup[current];
                                                    bits =
                                                      entry >>>
                                                        1 &
                                                        7;
                                                    code =
                                                      entry >>>
                                                        4 &
                                                        4095;
                                                    runLength +=
                                                      code;
                                                    updatePointer(
                                                      4 -
                                                        bits);
                                                }
                                                else
                                                    if (bits ==
                                                          15) {
                                                        throw new java.lang.Error(
                                                          "TIFFFaxDecoder2");
                                                    }
                                                    else {
                                                        runLength +=
                                                          code;
                                                        updatePointer(
                                                          9 -
                                                            bits);
                                                        if (isT ==
                                                              0) {
                                                            isWhite =
                                                              true;
                                                        }
                                                    }
                                            }
                                            else
                                                if (code ==
                                                      200) {
                                                    current =
                                                      nextLesserThan8Bits(
                                                        2);
                                                    entry =
                                                      twoBitBlack[current];
                                                    code =
                                                      entry >>>
                                                        5 &
                                                        2047;
                                                    runLength +=
                                                      code;
                                                    bits =
                                                      entry >>>
                                                        1 &
                                                        15;
                                                    updatePointer(
                                                      2 -
                                                        bits);
                                                    isWhite =
                                                      true;
                                                }
                                                else {
                                                    runLength +=
                                                      code;
                                                    updatePointer(
                                                      4 -
                                                        bits);
                                                    isWhite =
                                                      true;
                                                }
                                        }
                                        return runLength;
    }
    private int readEOL() { if (fillBits ==
                                  0) { if (nextNBits(
                                             12) !=
                                             1) {
                                           throw new java.lang.Error(
                                             "TIFFFaxDecoder6");
                                       } }
                            else
                                if (fillBits ==
                                      1) {
                                    int bitsLeft =
                                      8 -
                                      bitPointer;
                                    if (nextNBits(
                                          bitsLeft) !=
                                          0) {
                                        throw new java.lang.Error(
                                          "TIFFFaxDecoder8");
                                    }
                                    if (bitsLeft <
                                          4) {
                                        if (nextNBits(
                                              8) !=
                                              0) {
                                            throw new java.lang.Error(
                                              "TIFFFaxDecoder8");
                                        }
                                    }
                                    int n;
                                    while ((n =
                                              nextNBits(
                                                8)) !=
                                             1) {
                                        if (n !=
                                              0) {
                                            throw new java.lang.Error(
                                              "TIFFFaxDecoder8");
                                        }
                                    }
                                }
                            if (oneD == 0) {
                                return 1;
                            }
                            else {
                                return nextLesserThan8Bits(
                                         1);
                            } }
    private void getNextChangingElement(int a0,
                                        boolean isWhite,
                                        int[] ret) {
        int[] pce =
          this.
            prevChangingElems;
        int ces =
          this.
            changingElemSize;
        int start =
          lastChangingElement >
          0
          ? lastChangingElement -
          1
          : 0;
        if (isWhite) {
            start &=
              ~1;
        }
        else {
            start |=
              1;
        }
        int i =
          start;
        for (;
             i <
               ces;
             i +=
               2) {
            int temp =
              pce[i];
            if (temp >
                  a0) {
                lastChangingElement =
                  i;
                ret[0] =
                  temp;
                break;
            }
        }
        if (i +
              1 <
              ces) {
            ret[1] =
              pce[i +
                    1];
        }
    }
    private int nextNBits(int bitsToGet) {
        byte b;
        byte next;
        byte next2next;
        int l =
          data.
            length -
          1;
        int bp =
          this.
            bytePointer;
        if (fillOrder ==
              1) {
            b =
              data[bp];
            if (bp ==
                  l) {
                next =
                  0;
                next2next =
                  0;
            }
            else
                if (bp +
                      1 ==
                      l) {
                    next =
                      data[bp +
                             1];
                    next2next =
                      0;
                }
                else {
                    next =
                      data[bp +
                             1];
                    next2next =
                      data[bp +
                             2];
                }
        }
        else
            if (fillOrder ==
                  2) {
                b =
                  flipTable[data[bp] &
                              255];
                if (bp ==
                      l) {
                    next =
                      0;
                    next2next =
                      0;
                }
                else
                    if (bp +
                          1 ==
                          l) {
                        next =
                          flipTable[data[bp +
                                           1] &
                                      255];
                        next2next =
                          0;
                    }
                    else {
                        next =
                          flipTable[data[bp +
                                           1] &
                                      255];
                        next2next =
                          flipTable[data[bp +
                                           2] &
                                      255];
                    }
            }
            else {
                throw new java.lang.Error(
                  "TIFFFaxDecoder7");
            }
        int bitsLeft =
          8 -
          bitPointer;
        int bitsFromNextByte =
          bitsToGet -
          bitsLeft;
        int bitsFromNext2NextByte =
          0;
        if (bitsFromNextByte >
              8) {
            bitsFromNext2NextByte =
              bitsFromNextByte -
                8;
            bitsFromNextByte =
              8;
        }
        bytePointer++;
        int i1 =
          (b &
             table1[bitsLeft]) <<
          bitsToGet -
          bitsLeft;
        int i2 =
          (next &
             table2[bitsFromNextByte]) >>>
          8 -
          bitsFromNextByte;
        int i3 =
          0;
        if (bitsFromNext2NextByte !=
              0) {
            i2 <<=
              bitsFromNext2NextByte;
            i3 =
              (next2next &
                 table2[bitsFromNext2NextByte]) >>>
                8 -
                bitsFromNext2NextByte;
            i2 |=
              i3;
            bytePointer++;
            bitPointer =
              bitsFromNext2NextByte;
        }
        else {
            if (bitsFromNextByte ==
                  8) {
                bitPointer =
                  0;
                bytePointer++;
            }
            else {
                bitPointer =
                  bitsFromNextByte;
            }
        }
        int i =
          i1 |
          i2;
        return i;
    }
    private int nextLesserThan8Bits(int bitsToGet) {
        byte b;
        byte next;
        int l =
          data.
            length -
          1;
        int bp =
          this.
            bytePointer;
        if (fillOrder ==
              1) {
            b =
              data[bp];
            if (bp ==
                  l) {
                next =
                  0;
            }
            else {
                next =
                  data[bp +
                         1];
            }
        }
        else
            if (fillOrder ==
                  2) {
                b =
                  flipTable[data[bp] &
                              255];
                if (bp ==
                      l) {
                    next =
                      0;
                }
                else {
                    next =
                      flipTable[data[bp +
                                       1] &
                                  255];
                }
            }
            else {
                throw new java.lang.Error(
                  "TIFFFaxDecoder7");
            }
        int bitsLeft =
          8 -
          bitPointer;
        int bitsFromNextByte =
          bitsToGet -
          bitsLeft;
        int shift =
          bitsLeft -
          bitsToGet;
        int i1;
        int i2;
        if (shift >=
              0) {
            i1 =
              (b &
                 table1[bitsLeft]) >>>
                shift;
            bitPointer +=
              bitsToGet;
            if (bitPointer ==
                  8) {
                bitPointer =
                  0;
                bytePointer++;
            }
        }
        else {
            i1 =
              (b &
                 table1[bitsLeft]) <<
                -shift;
            i2 =
              (next &
                 table2[bitsFromNextByte]) >>>
                8 -
                bitsFromNextByte;
            i1 |=
              i2;
            bytePointer++;
            bitPointer =
              bitsFromNextByte;
        }
        return i1;
    }
    private void updatePointer(int bitsToMoveBack) {
        int i =
          bitPointer -
          bitsToMoveBack;
        if (i <
              0) {
            bytePointer--;
            bitPointer =
              8 +
                i;
        }
        else {
            bitPointer =
              i;
        }
    }
    private boolean advancePointer() { if (bitPointer !=
                                             0) {
                                           bytePointer++;
                                           bitPointer =
                                             0;
                                       }
                                       return true;
    }
    public static final java.lang.String jlc$CompilerVersion$jl7 =
      "2.7.0";
    public static final long jlc$SourceLastModified$jl7 =
      1471028785000L;
    public static final java.lang.String jlc$ClassType$jl7 =
      ("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" +
       "pMF9T29grhXdyC/x6tL/B84p5h9lPAAA");
    public static final java.lang.String jlc$CompilerVersion$jl5 =
      "2.7.0";
    public static final long jlc$SourceLastModified$jl5 =
      1471028785000L;
    public static final java.lang.String jlc$ClassType$jl5 =
      ("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" +
       "HMq5NjweN1B4buBDhkpKE8ZFxzWtuarU");
    public static final java.lang.String jlc$ClassType$jl5$1 =
      ("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" +
       "SgAA");
}
