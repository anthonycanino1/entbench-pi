package org.apache.batik.ext.awt.image.codec.tiff;
class TIFFFaxDecoder {
    private int bitPointer;
    private int bytePointer;
    private byte[] data;
    private int w;
    private int h;
    private int fillOrder;
    private int changingElemSize = 0;
    private int[] prevChangingElems;
    private int[] currChangingElems;
    private int lastChangingElement = 0;
    private int compression = 2;
    private int uncompressedMode = 0;
    private int fillBits = 0;
    private int oneD;
    static int[] table1 = { 0, 1, 3, 7, 15, 31, 63, 127, 255 };
    static int[] table2 = { 0, 128, 192, 224, 240, 248, 252, 254, 255 };
    static byte[] flipTable = { 0, -128, 64, -64, 32, -96, 96, -32, 16, -112,
    80,
    -48,
    48,
    -80,
    112,
    -16,
    8,
    -120,
    72,
    -56,
    40,
    -88,
    104,
    -24,
    24,
    -104,
    88,
    -40,
    56,
    -72,
    120,
    -8,
    4,
    -124,
    68,
    -60,
    36,
    -92,
    100,
    -28,
    20,
    -108,
    84,
    -44,
    52,
    -76,
    116,
    -12,
    12,
    -116,
    76,
    -52,
    44,
    -84,
    108,
    -20,
    28,
    -100,
    92,
    -36,
    60,
    -68,
    124,
    -4,
    2,
    -126,
    66,
    -62,
    34,
    -94,
    98,
    -30,
    18,
    -110,
    82,
    -46,
    50,
    -78,
    114,
    -14,
    10,
    -118,
    74,
    -54,
    42,
    -86,
    106,
    -22,
    26,
    -102,
    90,
    -38,
    58,
    -70,
    122,
    -6,
    6,
    -122,
    70,
    -58,
    38,
    -90,
    102,
    -26,
    22,
    -106,
    86,
    -42,
    54,
    -74,
    118,
    -10,
    14,
    -114,
    78,
    -50,
    46,
    -82,
    110,
    -18,
    30,
    -98,
    94,
    -34,
    62,
    -66,
    126,
    -2,
    1,
    -127,
    65,
    -63,
    33,
    -95,
    97,
    -31,
    17,
    -111,
    81,
    -47,
    49,
    -79,
    113,
    -15,
    9,
    -119,
    73,
    -55,
    41,
    -87,
    105,
    -23,
    25,
    -103,
    89,
    -39,
    57,
    -71,
    121,
    -7,
    5,
    -123,
    69,
    -59,
    37,
    -91,
    101,
    -27,
    21,
    -107,
    85,
    -43,
    53,
    -75,
    117,
    -11,
    13,
    -115,
    77,
    -51,
    45,
    -83,
    109,
    -19,
    29,
    -99,
    93,
    -35,
    61,
    -67,
    125,
    -3,
    3,
    -125,
    67,
    -61,
    35,
    -93,
    99,
    -29,
    19,
    -109,
    83,
    -45,
    51,
    -77,
    115,
    -13,
    11,
    -117,
    75,
    -53,
    43,
    -85,
    107,
    -21,
    27,
    -101,
    91,
    -37,
    59,
    -69,
    123,
    -5,
    7,
    -121,
    71,
    -57,
    39,
    -89,
    103,
    -25,
    23,
    -105,
    87,
    -41,
    55,
    -73,
    119,
    -9,
    15,
    -113,
    79,
    -49,
    47,
    -81,
    111,
    -17,
    31,
    -97,
    95,
    -33,
    63,
    -65,
    127,
    -1 };
    static short[] white = { 6430, 6400, 6400, 6400, 3225, 3225, 3225, 3225,
    944,
    944,
    944,
    944,
    976,
    976,
    976,
    976,
    1456,
    1456,
    1456,
    1456,
    1488,
    1488,
    1488,
    1488,
    718,
    718,
    718,
    718,
    718,
    718,
    718,
    718,
    750,
    750,
    750,
    750,
    750,
    750,
    750,
    750,
    1520,
    1520,
    1520,
    1520,
    1552,
    1552,
    1552,
    1552,
    428,
    428,
    428,
    428,
    428,
    428,
    428,
    428,
    428,
    428,
    428,
    428,
    428,
    428,
    428,
    428,
    654,
    654,
    654,
    654,
    654,
    654,
    654,
    654,
    1072,
    1072,
    1072,
    1072,
    1104,
    1104,
    1104,
    1104,
    1136,
    1136,
    1136,
    1136,
    1168,
    1168,
    1168,
    1168,
    1200,
    1200,
    1200,
    1200,
    1232,
    1232,
    1232,
    1232,
    622,
    622,
    622,
    622,
    622,
    622,
    622,
    622,
    1008,
    1008,
    1008,
    1008,
    1040,
    1040,
    1040,
    1040,
    44,
    44,
    44,
    44,
    44,
    44,
    44,
    44,
    44,
    44,
    44,
    44,
    44,
    44,
    44,
    44,
    396,
    396,
    396,
    396,
    396,
    396,
    396,
    396,
    396,
    396,
    396,
    396,
    396,
    396,
    396,
    396,
    1712,
    1712,
    1712,
    1712,
    1744,
    1744,
    1744,
    1744,
    846,
    846,
    846,
    846,
    846,
    846,
    846,
    846,
    1264,
    1264,
    1264,
    1264,
    1296,
    1296,
    1296,
    1296,
    1328,
    1328,
    1328,
    1328,
    1360,
    1360,
    1360,
    1360,
    1392,
    1392,
    1392,
    1392,
    1424,
    1424,
    1424,
    1424,
    686,
    686,
    686,
    686,
    686,
    686,
    686,
    686,
    910,
    910,
    910,
    910,
    910,
    910,
    910,
    910,
    1968,
    1968,
    1968,
    1968,
    2000,
    2000,
    2000,
    2000,
    2032,
    2032,
    2032,
    2032,
    16,
    16,
    16,
    16,
    10257,
    10257,
    10257,
    10257,
    12305,
    12305,
    12305,
    12305,
    330,
    330,
    330,
    330,
    330,
    330,
    330,
    330,
    330,
    330,
    330,
    330,
    330,
    330,
    330,
    330,
    330,
    330,
    330,
    330,
    330,
    330,
    330,
    330,
    330,
    330,
    330,
    330,
    330,
    330,
    330,
    330,
    362,
    362,
    362,
    362,
    362,
    362,
    362,
    362,
    362,
    362,
    362,
    362,
    362,
    362,
    362,
    362,
    362,
    362,
    362,
    362,
    362,
    362,
    362,
    362,
    362,
    362,
    362,
    362,
    362,
    362,
    362,
    362,
    878,
    878,
    878,
    878,
    878,
    878,
    878,
    878,
    1904,
    1904,
    1904,
    1904,
    1936,
    1936,
    1936,
    1936,
    -18413,
    -18413,
    -16365,
    -16365,
    -14317,
    -14317,
    -10221,
    -10221,
    590,
    590,
    590,
    590,
    590,
    590,
    590,
    590,
    782,
    782,
    782,
    782,
    782,
    782,
    782,
    782,
    1584,
    1584,
    1584,
    1584,
    1616,
    1616,
    1616,
    1616,
    1648,
    1648,
    1648,
    1648,
    1680,
    1680,
    1680,
    1680,
    814,
    814,
    814,
    814,
    814,
    814,
    814,
    814,
    1776,
    1776,
    1776,
    1776,
    1808,
    1808,
    1808,
    1808,
    1840,
    1840,
    1840,
    1840,
    1872,
    1872,
    1872,
    1872,
    6157,
    6157,
    6157,
    6157,
    6157,
    6157,
    6157,
    6157,
    6157,
    6157,
    6157,
    6157,
    6157,
    6157,
    6157,
    6157,
    -12275,
    -12275,
    -12275,
    -12275,
    -12275,
    -12275,
    -12275,
    -12275,
    -12275,
    -12275,
    -12275,
    -12275,
    -12275,
    -12275,
    -12275,
    -12275,
    14353,
    14353,
    14353,
    14353,
    16401,
    16401,
    16401,
    16401,
    22547,
    22547,
    24595,
    24595,
    20497,
    20497,
    20497,
    20497,
    18449,
    18449,
    18449,
    18449,
    26643,
    26643,
    28691,
    28691,
    30739,
    30739,
    -32749,
    -32749,
    -30701,
    -30701,
    -28653,
    -28653,
    -26605,
    -26605,
    -24557,
    -24557,
    -22509,
    -22509,
    -20461,
    -20461,
    8207,
    8207,
    8207,
    8207,
    8207,
    8207,
    8207,
    8207,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    72,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    104,
    4107,
    4107,
    4107,
    4107,
    4107,
    4107,
    4107,
    4107,
    4107,
    4107,
    4107,
    4107,
    4107,
    4107,
    4107,
    4107,
    4107,
    4107,
    4107,
    4107,
    4107,
    4107,
    4107,
    4107,
    4107,
    4107,
    4107,
    4107,
    4107,
    4107,
    4107,
    4107,
    266,
    266,
    266,
    266,
    266,
    266,
    266,
    266,
    266,
    266,
    266,
    266,
    266,
    266,
    266,
    266,
    266,
    266,
    266,
    266,
    266,
    266,
    266,
    266,
    266,
    266,
    266,
    266,
    266,
    266,
    266,
    266,
    298,
    298,
    298,
    298,
    298,
    298,
    298,
    298,
    298,
    298,
    298,
    298,
    298,
    298,
    298,
    298,
    298,
    298,
    298,
    298,
    298,
    298,
    298,
    298,
    298,
    298,
    298,
    298,
    298,
    298,
    298,
    298,
    524,
    524,
    524,
    524,
    524,
    524,
    524,
    524,
    524,
    524,
    524,
    524,
    524,
    524,
    524,
    524,
    556,
    556,
    556,
    556,
    556,
    556,
    556,
    556,
    556,
    556,
    556,
    556,
    556,
    556,
    556,
    556,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    136,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    168,
    460,
    460,
    460,
    460,
    460,
    460,
    460,
    460,
    460,
    460,
    460,
    460,
    460,
    460,
    460,
    460,
    492,
    492,
    492,
    492,
    492,
    492,
    492,
    492,
    492,
    492,
    492,
    492,
    492,
    492,
    492,
    492,
    2059,
    2059,
    2059,
    2059,
    2059,
    2059,
    2059,
    2059,
    2059,
    2059,
    2059,
    2059,
    2059,
    2059,
    2059,
    2059,
    2059,
    2059,
    2059,
    2059,
    2059,
    2059,
    2059,
    2059,
    2059,
    2059,
    2059,
    2059,
    2059,
    2059,
    2059,
    2059,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    200,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232,
    232 };
    static short[] additionalMakeup = { 28679, 28679, 31752, (short) 32777,
    (short)
      33801,
    (short)
      34825,
    (short)
      35849,
    (short)
      36873,
    (short)
      29703,
    (short)
      29703,
    (short)
      30727,
    (short)
      30727,
    (short)
      37897,
    (short)
      38921,
    (short)
      39945,
    (short)
      40969 };
    static short[] initBlack = { 3226, 6412, 200, 168, 38, 38, 134, 134, 100,
    100,
    100,
    100,
    68,
    68,
    68,
    68 };
    static short[] twoBitBlack = { 292, 260, 226, 226 };
    static short[] black = { 62, 62, 30, 30, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    3225,
    3225,
    3225,
    3225,
    3225,
    3225,
    3225,
    3225,
    3225,
    3225,
    3225,
    3225,
    3225,
    3225,
    3225,
    3225,
    3225,
    3225,
    3225,
    3225,
    3225,
    3225,
    3225,
    3225,
    3225,
    3225,
    3225,
    3225,
    3225,
    3225,
    3225,
    3225,
    588,
    588,
    588,
    588,
    588,
    588,
    588,
    588,
    1680,
    1680,
    20499,
    22547,
    24595,
    26643,
    1776,
    1776,
    1808,
    1808,
    -24557,
    -22509,
    -20461,
    -18413,
    1904,
    1904,
    1936,
    1936,
    -16365,
    -14317,
    782,
    782,
    782,
    782,
    814,
    814,
    814,
    814,
    -12269,
    -10221,
    10257,
    10257,
    12305,
    12305,
    14353,
    14353,
    16403,
    18451,
    1712,
    1712,
    1744,
    1744,
    28691,
    30739,
    -32749,
    -30701,
    -28653,
    -26605,
    2061,
    2061,
    2061,
    2061,
    2061,
    2061,
    2061,
    2061,
    424,
    424,
    424,
    424,
    424,
    424,
    424,
    424,
    424,
    424,
    424,
    424,
    424,
    424,
    424,
    424,
    424,
    424,
    424,
    424,
    424,
    424,
    424,
    424,
    424,
    424,
    424,
    424,
    424,
    424,
    424,
    424,
    750,
    750,
    750,
    750,
    1616,
    1616,
    1648,
    1648,
    1424,
    1424,
    1456,
    1456,
    1488,
    1488,
    1520,
    1520,
    1840,
    1840,
    1872,
    1872,
    1968,
    1968,
    8209,
    8209,
    524,
    524,
    524,
    524,
    524,
    524,
    524,
    524,
    556,
    556,
    556,
    556,
    556,
    556,
    556,
    556,
    1552,
    1552,
    1584,
    1584,
    2000,
    2000,
    2032,
    2032,
    976,
    976,
    1008,
    1008,
    1040,
    1040,
    1072,
    1072,
    1296,
    1296,
    1328,
    1328,
    718,
    718,
    718,
    718,
    456,
    456,
    456,
    456,
    456,
    456,
    456,
    456,
    456,
    456,
    456,
    456,
    456,
    456,
    456,
    456,
    456,
    456,
    456,
    456,
    456,
    456,
    456,
    456,
    456,
    456,
    456,
    456,
    456,
    456,
    456,
    456,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    326,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    358,
    490,
    490,
    490,
    490,
    490,
    490,
    490,
    490,
    490,
    490,
    490,
    490,
    490,
    490,
    490,
    490,
    4113,
    4113,
    6161,
    6161,
    848,
    848,
    880,
    880,
    912,
    912,
    944,
    944,
    622,
    622,
    622,
    622,
    654,
    654,
    654,
    654,
    1104,
    1104,
    1136,
    1136,
    1168,
    1168,
    1200,
    1200,
    1232,
    1232,
    1264,
    1264,
    686,
    686,
    686,
    686,
    1360,
    1360,
    1392,
    1392,
    12,
    12,
    12,
    12,
    12,
    12,
    12,
    12,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390,
    390 };
    static byte[] twoDCodes = { 80, 88, 23, 71, 30, 30, 62, 62, 4, 4, 4, 4,
    4,
    4,
    4,
    4,
    11,
    11,
    11,
    11,
    11,
    11,
    11,
    11,
    11,
    11,
    11,
    11,
    11,
    11,
    11,
    11,
    35,
    35,
    35,
    35,
    35,
    35,
    35,
    35,
    35,
    35,
    35,
    35,
    35,
    35,
    35,
    35,
    51,
    51,
    51,
    51,
    51,
    51,
    51,
    51,
    51,
    51,
    51,
    51,
    51,
    51,
    51,
    51,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41,
    41 };
    public TIFFFaxDecoder(int fillOrder, int w, int h) { super();
                                                         this.fillOrder =
                                                           fillOrder;
                                                         this.w = w;
                                                         this.h = h;
                                                         this.bitPointer =
                                                           0;
                                                         this.bytePointer =
                                                           0;
                                                         this.prevChangingElems =
                                                           (new int[w]);
                                                         this.currChangingElems =
                                                           (new int[w]);
    }
    public void decode1D(byte[] buffer, byte[] compData, int startX,
                         int height) { this.data = compData;
                                       int lineOffset = 0;
                                       int scanlineStride =
                                         (w +
                                            7) /
                                         8;
                                       bitPointer = 0;
                                       bytePointer = 0;
                                       for (int i = 0; i <
                                                         height;
                                            i++) { decodeNextScanline(
                                                     buffer,
                                                     lineOffset,
                                                     startX);
                                                   lineOffset +=
                                                     scanlineStride;
                                       } }
    public void decodeNextScanline(byte[] buffer, int lineOffset,
                                   int bitOffset) { int bits =
                                                      0;
                                                    int code =
                                                      0;
                                                    int isT =
                                                      0;
                                                    int current;
                                                    int entry;
                                                    int twoBits;
                                                    boolean isWhite =
                                                      true;
                                                    changingElemSize =
                                                      0;
                                                    while (bitOffset <
                                                             w) {
                                                        while (isWhite) {
                                                            current =
                                                              nextNBits(
                                                                10);
                                                            entry =
                                                              white[current];
                                                            isT =
                                                              entry &
                                                                1;
                                                            bits =
                                                              entry >>>
                                                                1 &
                                                                15;
                                                            if (bits ==
                                                                  12) {
                                                                twoBits =
                                                                  nextLesserThan8Bits(
                                                                    2);
                                                                current =
                                                                  current <<
                                                                    2 &
                                                                    12 |
                                                                    twoBits;
                                                                entry =
                                                                  additionalMakeup[current];
                                                                bits =
                                                                  entry >>>
                                                                    1 &
                                                                    7;
                                                                code =
                                                                  entry >>>
                                                                    4 &
                                                                    4095;
                                                                bitOffset +=
                                                                  code;
                                                                updatePointer(
                                                                  4 -
                                                                    bits);
                                                            }
                                                            else
                                                                if (bits ==
                                                                      0) {
                                                                    throw new java.lang.Error(
                                                                      "TIFFFaxDecoder0");
                                                                }
                                                                else
                                                                    if (bits ==
                                                                          15) {
                                                                        throw new java.lang.Error(
                                                                          "TIFFFaxDecoder1");
                                                                    }
                                                                    else {
                                                                        code =
                                                                          entry >>>
                                                                            5 &
                                                                            2047;
                                                                        bitOffset +=
                                                                          code;
                                                                        updatePointer(
                                                                          10 -
                                                                            bits);
                                                                        if (isT ==
                                                                              0) {
                                                                            isWhite =
                                                                              false;
                                                                            currChangingElems[changingElemSize++] =
                                                                              bitOffset;
                                                                        }
                                                                    }
                                                        }
                                                        if (bitOffset ==
                                                              w) {
                                                            if (compression ==
                                                                  2) {
                                                                advancePointer(
                                                                  );
                                                            }
                                                            break;
                                                        }
                                                        while (!isWhite) {
                                                            current =
                                                              nextLesserThan8Bits(
                                                                4);
                                                            entry =
                                                              initBlack[current];
                                                            isT =
                                                              entry &
                                                                1;
                                                            bits =
                                                              entry >>>
                                                                1 &
                                                                15;
                                                            code =
                                                              entry >>>
                                                                5 &
                                                                2047;
                                                            if (code ==
                                                                  100) {
                                                                current =
                                                                  nextNBits(
                                                                    9);
                                                                entry =
                                                                  black[current];
                                                                isT =
                                                                  entry &
                                                                    1;
                                                                bits =
                                                                  entry >>>
                                                                    1 &
                                                                    15;
                                                                code =
                                                                  entry >>>
                                                                    5 &
                                                                    2047;
                                                                if (bits ==
                                                                      12) {
                                                                    updatePointer(
                                                                      5);
                                                                    current =
                                                                      nextLesserThan8Bits(
                                                                        4);
                                                                    entry =
                                                                      additionalMakeup[current];
                                                                    bits =
                                                                      entry >>>
                                                                        1 &
                                                                        7;
                                                                    code =
                                                                      entry >>>
                                                                        4 &
                                                                        4095;
                                                                    setToBlack(
                                                                      buffer,
                                                                      lineOffset,
                                                                      bitOffset,
                                                                      code);
                                                                    bitOffset +=
                                                                      code;
                                                                    updatePointer(
                                                                      4 -
                                                                        bits);
                                                                }
                                                                else
                                                                    if (bits ==
                                                                          15) {
                                                                        throw new java.lang.Error(
                                                                          "TIFFFaxDecoder2");
                                                                    }
                                                                    else {
                                                                        setToBlack(
                                                                          buffer,
                                                                          lineOffset,
                                                                          bitOffset,
                                                                          code);
                                                                        bitOffset +=
                                                                          code;
                                                                        updatePointer(
                                                                          9 -
                                                                            bits);
                                                                        if (isT ==
                                                                              0) {
                                                                            isWhite =
                                                                              true;
                                                                            currChangingElems[changingElemSize++] =
                                                                              bitOffset;
                                                                        }
                                                                    }
                                                            }
                                                            else
                                                                if (code ==
                                                                      200) {
                                                                    current =
                                                                      nextLesserThan8Bits(
                                                                        2);
                                                                    entry =
                                                                      twoBitBlack[current];
                                                                    code =
                                                                      entry >>>
                                                                        5 &
                                                                        2047;
                                                                    bits =
                                                                      entry >>>
                                                                        1 &
                                                                        15;
                                                                    setToBlack(
                                                                      buffer,
                                                                      lineOffset,
                                                                      bitOffset,
                                                                      code);
                                                                    bitOffset +=
                                                                      code;
                                                                    updatePointer(
                                                                      2 -
                                                                        bits);
                                                                    isWhite =
                                                                      true;
                                                                    currChangingElems[changingElemSize++] =
                                                                      bitOffset;
                                                                }
                                                                else {
                                                                    setToBlack(
                                                                      buffer,
                                                                      lineOffset,
                                                                      bitOffset,
                                                                      code);
                                                                    bitOffset +=
                                                                      code;
                                                                    updatePointer(
                                                                      4 -
                                                                        bits);
                                                                    isWhite =
                                                                      true;
                                                                    currChangingElems[changingElemSize++] =
                                                                      bitOffset;
                                                                }
                                                        }
                                                        if (bitOffset ==
                                                              w) {
                                                            if (compression ==
                                                                  2) {
                                                                advancePointer(
                                                                  );
                                                            }
                                                            break;
                                                        }
                                                    }
                                                    currChangingElems[changingElemSize++] =
                                                      bitOffset;
    }
    public void decode2D(byte[] buffer, byte[] compData,
                         int startX,
                         int height,
                         long tiffT4Options) {
        this.
          data =
          compData;
        compression =
          3;
        bitPointer =
          0;
        bytePointer =
          0;
        int scanlineStride =
          (w +
             7) /
          8;
        int a0;
        int a1;
        int b1;
        int b2;
        int[] b =
          new int[2];
        int entry;
        int code;
        int bits;
        boolean isWhite;
        int currIndex =
          0;
        int[] temp;
        oneD =
          (int)
            (tiffT4Options &
               1);
        uncompressedMode =
          (int)
            ((tiffT4Options &
                2) >>
               1);
        fillBits =
          (int)
            ((tiffT4Options &
                4) >>
               2);
        if (readEOL(
              ) !=
              1) {
            throw new java.lang.Error(
              "TIFFFaxDecoder3");
        }
        int lineOffset =
          0;
        int bitOffset;
        decodeNextScanline(
          buffer,
          lineOffset,
          startX);
        lineOffset +=
          scanlineStride;
        for (int lines =
               1;
             lines <
               height;
             lines++) {
            if (readEOL(
                  ) ==
                  0) {
                temp =
                  prevChangingElems;
                prevChangingElems =
                  currChangingElems;
                currChangingElems =
                  temp;
                currIndex =
                  0;
                a0 =
                  -1;
                isWhite =
                  true;
                bitOffset =
                  startX;
                lastChangingElement =
                  0;
                while (bitOffset <
                         w) {
                    getNextChangingElement(
                      a0,
                      isWhite,
                      b);
                    b1 =
                      b[0];
                    b2 =
                      b[1];
                    entry =
                      nextLesserThan8Bits(
                        7);
                    entry =
                      (int)
                        (twoDCodes[entry] &
                           255);
                    code =
                      (entry &
                         120) >>>
                        3;
                    bits =
                      entry &
                        7;
                    if (code ==
                          0) {
                        if (!isWhite) {
                            setToBlack(
                              buffer,
                              lineOffset,
                              bitOffset,
                              b2 -
                                bitOffset);
                        }
                        bitOffset =
                          (a0 =
                             b2);
                        updatePointer(
                          7 -
                            bits);
                    }
                    else
                        if (code ==
                              1) {
                            updatePointer(
                              7 -
                                bits);
                            int number;
                            if (isWhite) {
                                number =
                                  decodeWhiteCodeWord(
                                    );
                                bitOffset +=
                                  number;
                                currChangingElems[currIndex++] =
                                  bitOffset;
                                number =
                                  decodeBlackCodeWord(
                                    );
                                setToBlack(
                                  buffer,
                                  lineOffset,
                                  bitOffset,
                                  number);
                                bitOffset +=
                                  number;
                                currChangingElems[currIndex++] =
                                  bitOffset;
                            }
                            else {
                                number =
                                  decodeBlackCodeWord(
                                    );
                                setToBlack(
                                  buffer,
                                  lineOffset,
                                  bitOffset,
                                  number);
                                bitOffset +=
                                  number;
                                currChangingElems[currIndex++] =
                                  bitOffset;
                                number =
                                  decodeWhiteCodeWord(
                                    );
                                bitOffset +=
                                  number;
                                currChangingElems[currIndex++] =
                                  bitOffset;
                            }
                            a0 =
                              bitOffset;
                        }
                        else
                            if (code <=
                                  8) {
                                a1 =
                                  b1 +
                                    (code -
                                       5);
                                currChangingElems[currIndex++] =
                                  a1;
                                if (!isWhite) {
                                    setToBlack(
                                      buffer,
                                      lineOffset,
                                      bitOffset,
                                      a1 -
                                        bitOffset);
                                }
                                bitOffset =
                                  (a0 =
                                     a1);
                                isWhite =
                                  !isWhite;
                                updatePointer(
                                  7 -
                                    bits);
                            }
                            else {
                                throw new java.lang.Error(
                                  "TIFFFaxDecoder4");
                            }
                }
                currChangingElems[currIndex++] =
                  bitOffset;
                changingElemSize =
                  currIndex;
            }
            else {
                decodeNextScanline(
                  buffer,
                  lineOffset,
                  startX);
            }
            lineOffset +=
              scanlineStride;
        }
    }
    public synchronized void decodeT6(byte[] buffer,
                                      byte[] compData,
                                      int startX,
                                      int height,
                                      long tiffT6Options) {
        this.
          data =
          compData;
        compression =
          4;
        bitPointer =
          0;
        bytePointer =
          0;
        int scanlineStride =
          (w +
             7) /
          8;
        int a0;
        int a1;
        int b1;
        int b2;
        int entry;
        int code;
        int bits;
        boolean isWhite;
        int currIndex;
        int[] temp;
        int[] b =
          new int[2];
        uncompressedMode =
          (int)
            ((tiffT6Options &
                2) >>
               1);
        int[] cce =
          currChangingElems;
        changingElemSize =
          0;
        cce[changingElemSize++] =
          w;
        cce[changingElemSize++] =
          w;
        int lineOffset =
          0;
        int bitOffset;
        for (int lines =
               0;
             lines <
               height;
             lines++) {
            a0 =
              -1;
            isWhite =
              true;
            temp =
              prevChangingElems;
            prevChangingElems =
              currChangingElems;
            cce =
              (currChangingElems =
                 temp);
            currIndex =
              0;
            bitOffset =
              startX;
            lastChangingElement =
              0;
            while (bitOffset <
                     w) {
                getNextChangingElement(
                  a0,
                  isWhite,
                  b);
                b1 =
                  b[0];
                b2 =
                  b[1];
                entry =
                  nextLesserThan8Bits(
                    7);
                entry =
                  (int)
                    (twoDCodes[entry] &
                       255);
                code =
                  (entry &
                     120) >>>
                    3;
                bits =
                  entry &
                    7;
                if (code ==
                      0) {
                    if (!isWhite) {
                        setToBlack(
                          buffer,
                          lineOffset,
                          bitOffset,
                          b2 -
                            bitOffset);
                    }
                    bitOffset =
                      (a0 =
                         b2);
                    updatePointer(
                      7 -
                        bits);
                }
                else
                    if (code ==
                          1) {
                        updatePointer(
                          7 -
                            bits);
                        int number;
                        if (isWhite) {
                            number =
                              decodeWhiteCodeWord(
                                );
                            bitOffset +=
                              number;
                            cce[currIndex++] =
                              bitOffset;
                            number =
                              decodeBlackCodeWord(
                                );
                            setToBlack(
                              buffer,
                              lineOffset,
                              bitOffset,
                              number);
                            bitOffset +=
                              number;
                            cce[currIndex++] =
                              bitOffset;
                        }
                        else {
                            number =
                              decodeBlackCodeWord(
                                );
                            setToBlack(
                              buffer,
                              lineOffset,
                              bitOffset,
                              number);
                            bitOffset +=
                              number;
                            cce[currIndex++] =
                              bitOffset;
                            number =
                              decodeWhiteCodeWord(
                                );
                            bitOffset +=
                              number;
                            cce[currIndex++] =
                              bitOffset;
                        }
                        a0 =
                          bitOffset;
                    }
                    else
                        if (code <=
                              8) {
                            a1 =
                              b1 +
                                (code -
                                   5);
                            cce[currIndex++] =
                              a1;
                            if (!isWhite) {
                                setToBlack(
                                  buffer,
                                  lineOffset,
                                  bitOffset,
                                  a1 -
                                    bitOffset);
                            }
                            bitOffset =
                              (a0 =
                                 a1);
                            isWhite =
                              !isWhite;
                            updatePointer(
                              7 -
                                bits);
                        }
                        else
                            if (code ==
                                  11) {
                                if (nextLesserThan8Bits(
                                      3) !=
                                      7) {
                                    throw new java.lang.Error(
                                      "TIFFFaxDecoder5");
                                }
                                int zeros =
                                  0;
                                boolean exit =
                                  false;
                                while (!exit) {
                                    while (nextLesserThan8Bits(
                                             1) !=
                                             1) {
                                        zeros++;
                                    }
                                    if (zeros >
                                          5) {
                                        zeros =
                                          zeros -
                                            6;
                                        if (!isWhite &&
                                              zeros >
                                              0) {
                                            cce[currIndex++] =
                                              bitOffset;
                                        }
                                        bitOffset +=
                                          zeros;
                                        if (zeros >
                                              0) {
                                            isWhite =
                                              true;
                                        }
                                        if (nextLesserThan8Bits(
                                              1) ==
                                              0) {
                                            if (!isWhite) {
                                                cce[currIndex++] =
                                                  bitOffset;
                                            }
                                            isWhite =
                                              true;
                                        }
                                        else {
                                            if (isWhite) {
                                                cce[currIndex++] =
                                                  bitOffset;
                                            }
                                            isWhite =
                                              false;
                                        }
                                        exit =
                                          true;
                                    }
                                    if (zeros ==
                                          5) {
                                        if (!isWhite) {
                                            cce[currIndex++] =
                                              bitOffset;
                                        }
                                        bitOffset +=
                                          zeros;
                                        isWhite =
                                          true;
                                    }
                                    else {
                                        bitOffset +=
                                          zeros;
                                        cce[currIndex++] =
                                          bitOffset;
                                        setToBlack(
                                          buffer,
                                          lineOffset,
                                          bitOffset,
                                          1);
                                        ++bitOffset;
                                        isWhite =
                                          false;
                                    }
                                }
                            }
                            else {
                                throw new java.lang.Error(
                                  "TIFFFaxDecoder5");
                            }
            }
            cce[currIndex++] =
              bitOffset;
            changingElemSize =
              currIndex;
            lineOffset +=
              scanlineStride;
        }
    }
    private void setToBlack(byte[] buffer,
                            int lineOffset,
                            int bitOffset,
                            int numBits) {
        int bitNum =
          8 *
          lineOffset +
          bitOffset;
        int lastBit =
          bitNum +
          numBits;
        int byteNum =
          bitNum >>
          3;
        int shift =
          bitNum &
          7;
        if (shift >
              0) {
            int maskVal =
              1 <<
              7 -
              shift;
            byte val =
              buffer[byteNum];
            while (maskVal >
                     0 &&
                     bitNum <
                     lastBit) {
                val |=
                  maskVal;
                maskVal >>=
                  1;
                ++bitNum;
            }
            buffer[byteNum] =
              val;
        }
        byteNum =
          bitNum >>
            3;
        while (bitNum <
                 lastBit -
                 7) {
            buffer[byteNum++] =
              (byte)
                255;
            bitNum +=
              8;
        }
        while (bitNum <
                 lastBit) {
            byteNum =
              bitNum >>
                3;
            buffer[byteNum] |=
              1 <<
                7 -
                (bitNum &
                   7);
            ++bitNum;
        }
    }
    private int decodeWhiteCodeWord() { int current;
                                        int entry;
                                        int bits;
                                        int isT;
                                        int twoBits;
                                        int code =
                                          -1;
                                        int runLength =
                                          0;
                                        boolean isWhite =
                                          true;
                                        while (isWhite) {
                                            current =
                                              nextNBits(
                                                10);
                                            entry =
                                              white[current];
                                            isT =
                                              entry &
                                                1;
                                            bits =
                                              entry >>>
                                                1 &
                                                15;
                                            if (bits ==
                                                  12) {
                                                twoBits =
                                                  nextLesserThan8Bits(
                                                    2);
                                                current =
                                                  current <<
                                                    2 &
                                                    12 |
                                                    twoBits;
                                                entry =
                                                  additionalMakeup[current];
                                                bits =
                                                  entry >>>
                                                    1 &
                                                    7;
                                                code =
                                                  entry >>>
                                                    4 &
                                                    4095;
                                                runLength +=
                                                  code;
                                                updatePointer(
                                                  4 -
                                                    bits);
                                            }
                                            else
                                                if (bits ==
                                                      0) {
                                                    throw new java.lang.Error(
                                                      "TIFFFaxDecoder0");
                                                }
                                                else
                                                    if (bits ==
                                                          15) {
                                                        throw new java.lang.Error(
                                                          "TIFFFaxDecoder1");
                                                    }
                                                    else {
                                                        code =
                                                          entry >>>
                                                            5 &
                                                            2047;
                                                        runLength +=
                                                          code;
                                                        updatePointer(
                                                          10 -
                                                            bits);
                                                        if (isT ==
                                                              0) {
                                                            isWhite =
                                                              false;
                                                        }
                                                    }
                                        }
                                        return runLength;
    }
    private int decodeBlackCodeWord() { int current;
                                        int entry;
                                        int bits;
                                        int isT;
                                        int code =
                                          -1;
                                        int runLength =
                                          0;
                                        boolean isWhite =
                                          false;
                                        while (!isWhite) {
                                            current =
                                              nextLesserThan8Bits(
                                                4);
                                            entry =
                                              initBlack[current];
                                            isT =
                                              entry &
                                                1;
                                            bits =
                                              entry >>>
                                                1 &
                                                15;
                                            code =
                                              entry >>>
                                                5 &
                                                2047;
                                            if (code ==
                                                  100) {
                                                current =
                                                  nextNBits(
                                                    9);
                                                entry =
                                                  black[current];
                                                isT =
                                                  entry &
                                                    1;
                                                bits =
                                                  entry >>>
                                                    1 &
                                                    15;
                                                code =
                                                  entry >>>
                                                    5 &
                                                    2047;
                                                if (bits ==
                                                      12) {
                                                    updatePointer(
                                                      5);
                                                    current =
                                                      nextLesserThan8Bits(
                                                        4);
                                                    entry =
                                                      additionalMakeup[current];
                                                    bits =
                                                      entry >>>
                                                        1 &
                                                        7;
                                                    code =
                                                      entry >>>
                                                        4 &
                                                        4095;
                                                    runLength +=
                                                      code;
                                                    updatePointer(
                                                      4 -
                                                        bits);
                                                }
                                                else
                                                    if (bits ==
                                                          15) {
                                                        throw new java.lang.Error(
                                                          "TIFFFaxDecoder2");
                                                    }
                                                    else {
                                                        runLength +=
                                                          code;
                                                        updatePointer(
                                                          9 -
                                                            bits);
                                                        if (isT ==
                                                              0) {
                                                            isWhite =
                                                              true;
                                                        }
                                                    }
                                            }
                                            else
                                                if (code ==
                                                      200) {
                                                    current =
                                                      nextLesserThan8Bits(
                                                        2);
                                                    entry =
                                                      twoBitBlack[current];
                                                    code =
                                                      entry >>>
                                                        5 &
                                                        2047;
                                                    runLength +=
                                                      code;
                                                    bits =
                                                      entry >>>
                                                        1 &
                                                        15;
                                                    updatePointer(
                                                      2 -
                                                        bits);
                                                    isWhite =
                                                      true;
                                                }
                                                else {
                                                    runLength +=
                                                      code;
                                                    updatePointer(
                                                      4 -
                                                        bits);
                                                    isWhite =
                                                      true;
                                                }
                                        }
                                        return runLength;
    }
    private int readEOL() { if (fillBits ==
                                  0) { if (nextNBits(
                                             12) !=
                                             1) {
                                           throw new java.lang.Error(
                                             "TIFFFaxDecoder6");
                                       } }
                            else
                                if (fillBits ==
                                      1) {
                                    int bitsLeft =
                                      8 -
                                      bitPointer;
                                    if (nextNBits(
                                          bitsLeft) !=
                                          0) {
                                        throw new java.lang.Error(
                                          "TIFFFaxDecoder8");
                                    }
                                    if (bitsLeft <
                                          4) {
                                        if (nextNBits(
                                              8) !=
                                              0) {
                                            throw new java.lang.Error(
                                              "TIFFFaxDecoder8");
                                        }
                                    }
                                    int n;
                                    while ((n =
                                              nextNBits(
                                                8)) !=
                                             1) {
                                        if (n !=
                                              0) {
                                            throw new java.lang.Error(
                                              "TIFFFaxDecoder8");
                                        }
                                    }
                                }
                            if (oneD == 0) {
                                return 1;
                            }
                            else {
                                return nextLesserThan8Bits(
                                         1);
                            } }
    private void getNextChangingElement(int a0,
                                        boolean isWhite,
                                        int[] ret) {
        int[] pce =
          this.
            prevChangingElems;
        int ces =
          this.
            changingElemSize;
        int start =
          lastChangingElement >
          0
          ? lastChangingElement -
          1
          : 0;
        if (isWhite) {
            start &=
              ~1;
        }
        else {
            start |=
              1;
        }
        int i =
          start;
        for (;
             i <
               ces;
             i +=
               2) {
            int temp =
              pce[i];
            if (temp >
                  a0) {
                lastChangingElement =
                  i;
                ret[0] =
                  temp;
                break;
            }
        }
        if (i +
              1 <
              ces) {
            ret[1] =
              pce[i +
                    1];
        }
    }
    private int nextNBits(int bitsToGet) {
        byte b;
        byte next;
        byte next2next;
        int l =
          data.
            length -
          1;
        int bp =
          this.
            bytePointer;
        if (fillOrder ==
              1) {
            b =
              data[bp];
            if (bp ==
                  l) {
                next =
                  0;
                next2next =
                  0;
            }
            else
                if (bp +
                      1 ==
                      l) {
                    next =
                      data[bp +
                             1];
                    next2next =
                      0;
                }
                else {
                    next =
                      data[bp +
                             1];
                    next2next =
                      data[bp +
                             2];
                }
        }
        else
            if (fillOrder ==
                  2) {
                b =
                  flipTable[data[bp] &
                              255];
                if (bp ==
                      l) {
                    next =
                      0;
                    next2next =
                      0;
                }
                else
                    if (bp +
                          1 ==
                          l) {
                        next =
                          flipTable[data[bp +
                                           1] &
                                      255];
                        next2next =
                          0;
                    }
                    else {
                        next =
                          flipTable[data[bp +
                                           1] &
                                      255];
                        next2next =
                          flipTable[data[bp +
                                           2] &
                                      255];
                    }
            }
            else {
                throw new java.lang.Error(
                  "TIFFFaxDecoder7");
            }
        int bitsLeft =
          8 -
          bitPointer;
        int bitsFromNextByte =
          bitsToGet -
          bitsLeft;
        int bitsFromNext2NextByte =
          0;
        if (bitsFromNextByte >
              8) {
            bitsFromNext2NextByte =
              bitsFromNextByte -
                8;
            bitsFromNextByte =
              8;
        }
        bytePointer++;
        int i1 =
          (b &
             table1[bitsLeft]) <<
          bitsToGet -
          bitsLeft;
        int i2 =
          (next &
             table2[bitsFromNextByte]) >>>
          8 -
          bitsFromNextByte;
        int i3 =
          0;
        if (bitsFromNext2NextByte !=
              0) {
            i2 <<=
              bitsFromNext2NextByte;
            i3 =
              (next2next &
                 table2[bitsFromNext2NextByte]) >>>
                8 -
                bitsFromNext2NextByte;
            i2 |=
              i3;
            bytePointer++;
            bitPointer =
              bitsFromNext2NextByte;
        }
        else {
            if (bitsFromNextByte ==
                  8) {
                bitPointer =
                  0;
                bytePointer++;
            }
            else {
                bitPointer =
                  bitsFromNextByte;
            }
        }
        int i =
          i1 |
          i2;
        return i;
    }
    private int nextLesserThan8Bits(int bitsToGet) {
        byte b;
        byte next;
        int l =
          data.
            length -
          1;
        int bp =
          this.
            bytePointer;
        if (fillOrder ==
              1) {
            b =
              data[bp];
            if (bp ==
                  l) {
                next =
                  0;
            }
            else {
                next =
                  data[bp +
                         1];
            }
        }
        else
            if (fillOrder ==
                  2) {
                b =
                  flipTable[data[bp] &
                              255];
                if (bp ==
                      l) {
                    next =
                      0;
                }
                else {
                    next =
                      flipTable[data[bp +
                                       1] &
                                  255];
                }
            }
            else {
                throw new java.lang.Error(
                  "TIFFFaxDecoder7");
            }
        int bitsLeft =
          8 -
          bitPointer;
        int bitsFromNextByte =
          bitsToGet -
          bitsLeft;
        int shift =
          bitsLeft -
          bitsToGet;
        int i1;
        int i2;
        if (shift >=
              0) {
            i1 =
              (b &
                 table1[bitsLeft]) >>>
                shift;
            bitPointer +=
              bitsToGet;
            if (bitPointer ==
                  8) {
                bitPointer =
                  0;
                bytePointer++;
            }
        }
        else {
            i1 =
              (b &
                 table1[bitsLeft]) <<
                -shift;
            i2 =
              (next &
                 table2[bitsFromNextByte]) >>>
                8 -
                bitsFromNextByte;
            i1 |=
              i2;
            bytePointer++;
            bitPointer =
              bitsFromNextByte;
        }
        return i1;
    }
    private void updatePointer(int bitsToMoveBack) {
        int i =
          bitPointer -
          bitsToMoveBack;
        if (i <
              0) {
            bytePointer--;
            bitPointer =
              8 +
                i;
        }
        else {
            bitPointer =
              i;
        }
    }
    private boolean advancePointer() { if (bitPointer !=
                                             0) {
                                           bytePointer++;
                                           bitPointer =
                                             0;
                                       }
                                       return true;
    }
    public static final java.lang.String jlc$CompilerVersion$jl7 =
      "2.7.0";
    public static final long jlc$SourceLastModified$jl7 =
      1471109864000L;
    public static final java.lang.String jlc$ClassType$jl7 =
      ("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" +
       "zeC+pzcw14pu5Jd4dfHfAccRtFNlPAAA");
    public static final java.lang.String jlc$CompilerVersion$jl5 =
      "2.7.0";
    public static final long jlc$SourceLastModified$jl5 =
      1471109864000L;
    public static final java.lang.String jlc$ClassType$jl5 =
      ("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" +
       "uN5fV0ekNJCYUYFyiNmCdec6LjWUkVhr");
    public static final java.lang.String jlc$ClassType$jl5$1 =
      ("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" +
       "b9X9f220AjNiSgAA");
}
